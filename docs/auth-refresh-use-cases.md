# Auth и Refresh: кейсы использования

Документ описывает, когда вызывается refresh, когда пользователь остаётся в сессии, и когда происходит выход на логин. **Цель:** refresh вызывается всегда, где нужно, и не бывает лишних выходов из аккаунта.

---

## Правило в коде

- **Любой запрос через `request()` из `src/shared/api/client.ts`** к **непубличному** path при ответе **401**:
  1. **Сначала** один раз вызывается `POST /api/auth/refresh` (с `credentials: 'include'`).
  2. При **успехе** (200) исходный запрос **повторяется**; пользователь остаётся в сессии.
  3. При **неуспехе** refresh (401/403/404) вызывается `sessionExpiredHandler(path)` и возвращается 401 — приложение очищает user и редиректит на логин (с сообщением «Сессия истекла», кроме явного logout).

- **Публичные path:** при 401 refresh **не** вызывается (избегаем цикла и лишнего редиректа).

---

## Публичные эндпоинты (refresh при 401 не вызывается)

| Path | Использование |
|------|----------------|
| `POST /api/auth/login` | Страница логина |
| `POST /api/auth/refresh` | Внутренний вызов клиента (сырой fetch) |
| `GET /api/invitations/validate` | Страница приглашения: проверка токена |
| `POST /api/invitations/accept` | Страница приглашения: принятие и активация |

---

## Кейсы использования приложения

### 1. Первый заход / обновление страницы (авторизован, access истёк, refresh жив)

- **Событие:** монтируется `AuthProvider`, вызывается `me()`.
- **Запрос:** `GET /api/auth/me` → 401.
- **Поведение:** клиент вызывает refresh → 200 → повторяет `me()` → 200 → `setUser(data)`. Пользователь остаётся в сессии, редиректа на логин нет.

### 2. Первый заход / обновление (сессия мёртва: refresh истёк или отозван)

- **Событие:** `me()` → 401.
- **Поведение:** refresh → 401/403/404 → `sessionExpiredHandler()` → очистка user, `sessionExpired = true` → редирект на `/login` с сообщением «Сессия истекла».

### 3. Работа в дашборде (запросы списков, форм, сохранение)

- **Событие:** любые вызовы API из entities (departments, programs, curricula, courses, teachers, students, lessons, schedule, groups) и т.д. — все идут через `request()`.
- **При 401:** refresh один раз на «волну» запросов → при успехе все запросы перезапускаются, пользователь в сессии. При неуспехе — как в кейсе 2.

### 4. Несколько запросов одновременно (волна 401)

- **Событие:** несколько защищённых запросов почти одновременно получили 401 (например, вкладка долго была в фоне).
- **Поведение:** только **один** вызов refresh; остальные ждут его результат. При успехе — все перезапрашиваются; при неуспехе — один вызов `sessionExpiredHandler`, редирект на логин.

### 5. Явный выход (кнопка «Выйти»)

- **Событие:** пользователь нажимает «Выйти» → `logout()` → `POST /api/auth/logout`. Если access уже истёк, запрос даёт 401.
- **Поведение:** клиент делает refresh; если refresh неуспешен → `sessionExpiredHandler('/api/auth/logout')`. В провайдере при path === `/api/auth/logout` **не** выставляется `sessionExpired`, чтобы не показывать «Сессия истекла» — пользователь сам вышел.

### 6. Логин

- **Событие:** `POST /api/auth/login` (публичный path).
- **При 401:** refresh не вызывается; показывается ошибка «Неверные учётные данные» и т.п.

### 7. Страница приглашения (без логина)

- **Событие:** `validateToken`, `acceptInvitation` (публичные path).
- **При 401:** refresh не вызывается; обрабатывается как невалидная ссылка/ошибка приглашения.

### 8. Сетевые ошибки и 5xx на refresh

- **Событие:** при 401 на защищённом запросе вызывается refresh, но запрос к refresh падает (сеть) или сервер возвращает 5xx.
- **Поведение:** `sessionExpiredHandler` **не** вызывается. Возвращается 401 по исходному запросу; пользователь **не** разлогинивается (можно повторить действие после восстановления сети/сервера).

### 9. Повторный запрос после успешного refresh (internalRetry)

- **Событие:** после успешного refresh клиент повторяет исходный запрос с `internalRetry: true`.
- **Поведение:** если этот повторный запрос снова вернёт 401, **второй** refresh не делается (избегаем цикла), возвращается 401. Обычно не происходит при корректных cookies после refresh.

### 10. Запросы только через `request()`

- Все вызовы к защищённому API должны идти через `request()` из `src/shared/api` (auth, invitations, entities/*/api). Тогда гарантируется единая логика 401 → refresh → повтор/выход.

---

## Итог

- Refresh вызывается **ровно там, где нужно:** при 401 на любом **непубличном** запросе, один раз на волну.
- Пользователь **не** будет выкинут на логин, если refresh мог продлить сессию (успешный 200 на refresh).
- Выход на логин с «Сессия истекла» — только при реальном неуспехе refresh (401/403/404) или при первом заходе с мёртвой сессией; при явном logout сообщение «Сессия истекла» не показывается.
